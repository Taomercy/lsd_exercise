#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <signal.h>
#include <time.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/msg.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <sys/ipc.h>
#include <pthread.h>
#include <semaphore.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include "mychat_model.h"
#include "mychat_ctrl.h"
char* get_array(char* str, char* filename, char* value)
{
	FILE* fp = fopen(filename,"r");
	if(fp == NULL)
	{
		return NULL;
	}
	while(1)
	{
		char buff_line[1024] = "";
		char buff1[1024] = "";
		char buff2[1024] = "";
		char buff3[1024] = "";
		if(fgets(buff_line,1024,fp) == NULL)
		{
			break;
		}
		sscanf(buff_line,"%s" "%s" "%s",buff1,buff2,buff3);
		if(strcmp(buff1,value) == 0)
		{
			fclose(fp);
			strcpy(str,buff3);
			return str;
		}
	}
	fclose(fp);
	return NULL;
}


void client_create(char* ip, char* port)//客户端创建
{
	int clientfd = socket(AF_INET,SOCK_STREAM,0);
	if(clientfd == -1)
	{
		fprintf(stderr,"文件名：%s\n函数名：%s\n行号：%d\n错误内容：%s\n",__FILE__,__func__,__LINE__,strerror(errno));
		exit(EXIT_FAILURE);
	}
	struct sockaddr_in s_addr;
	s_addr.sin_family = AF_INET;
	s_addr.sin_port = htons(atoi(port));
	if(inet_pton(AF_INET,ip,&s_addr.sin_addr.s_addr) == -1)
	{
		fprintf(stderr,"文件名：%s\n函数名：%s\n行号：%d\n错误内容：%s\n",__FILE__,__func__,__LINE__,strerror(errno));
		exit(EXIT_FAILURE);
	}
	if(connect(clientfd,(struct sockaddr*)&s_addr,sizeof(struct sockaddr)) == -1)
	{
		fprintf(stderr,"文件名：%s\n函数名：%s\n行号：%d\n错误内容：%s\n",__FILE__,__func__,__LINE__,strerror(errno));
		exit(EXIT_FAILURE);
	}

	//创建线程

	pthread_t pthread;
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr,PTHREAD_CREATE_DETACHED);

	int err = 0;
	if((err = pthread_create(&pthread,&attr,client_receive,(void*)clientfd))!=0)
	{
		fprintf(stderr,"文件名：%s 函数名：%s 行号：%d 错误原因：%s\n",__FILE__,__func__,__LINE__,strerror(errno));
		exit(EXIT_FAILURE);
	}
	
	//调用客户端主线程控制层
	client_ctrl_1(clientfd);
	
	close(clientfd);
	return;
}

void* client_receive(void* arg)//客户端数据接收线程，并同步到主线程
{
	printf("到达客户端数据接收线程！\n");
	int clientfd = (int)arg;
	while(1)
	{
		Cmsg core_message = {};
		if(read(clientfd,&core_message,sizeof(Cmsg)) <= 0)
		{
			fprintf(stderr,"服务器关闭！\n");
			break;
		}
		switch(core_message.type)
		{
			case REG:
				break;
			case LOG:
				break;
			case EXIT:
				break;
			default:
				printf("输入错误！\n");
				break;
		}
	}

	return NULL;
}

