#include "mychat_model.h"
#include "mychat_ctrl.h"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <signal.h>
#include <time.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/msg.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <sys/ipc.h>
#include <pthread.h>
#include <semaphore.h>
#include <arpa/inet.h>
#include <sys/socket.h>
char* get_array(char* str ,char* filename,char* value)//IP,port获取函数：成功返回str，失败返回NULL
{
	FILE* fp = fopen(filename,"r");
	if(fp == NULL)
	{
		return NULL;
	}

	while(1)
	{
		char buff_line[1024] = " ";
		char buff_1[1024] = " ";
		char buff_2[1024] = " ";
		char buff_3[1024] = " ";
		if(fgets(buff_line,1024,fp) == NULL)
		{
			break;
		} 	
		sscanf(buff_line,"%s %s %s",buff_1,buff_2,buff_3);
		if(strcmp(buff_1,value) == 0)
		{
			fclose(fp);
			strcpy(str,buff_3);
			return str;
		}
	}	
	fclose(fp);
	return NULL;
}

void server_create(char* ip, char* port)//服务器创建函数
{
	int serverfd = socket(AF_INET,SOCK_STREAM,0);//创建套接字
	if(serverfd == -1)
	{
		fprintf(stderr,"文件名：%s\n函数名：%s\n行号：%d\n错误内容：%s\n",__FILE__,__func__,__LINE__,strerror(errno));
		exit(EXIT_FAILURE);
	}
	struct sockaddr_in s_addr = {};//定义服务器因特网地址结构体
	s_addr.sin_family = AF_INET;//设置网域
	s_addr.sin_port = htons(atoi(port));//设置端口
	s_addr.sin_addr.s_addr = INADDR_ANY;

/*	if(inet_pton(AF_INET,ip,&s_addr.sin_addr.s_addr) == -1)
	{
		fprintf(stderr,"文件名：%s\n函数名：%s\n行号：%d\n错误内容：%s\n",__FILE__,__func__,__LINE__,strerror(errno));
		exit(EXIT_FAILURE);	
	}
*/
	if(bind(serverfd,(struct sockaddr*)&s_addr,sizeof(s_addr)) == -1)//服务器绑定IP,port
	{
		fprintf(stderr,"文件名：%s\n函数名：%s\n行号：%d\n错误内容：%s\n",__FILE__,__func__,__LINE__,strerror(errno));
		exit(EXIT_FAILURE);
	}
	
	if(listen(serverfd,10) == -1)//设置监听队列
	{
		fprintf(stderr,"文件名：%s\n函数名：%s\n行号：%d\n错误内容：%s\n",__FILE__,__func__,__LINE__,strerror(errno));
		exit(EXIT_FAILURE);
	}
	while(1)
	{
		struct sockaddr_in client_addr;//用来接收客户端因特网地址
		socklen_t client_len = sizeof(client_addr);
		int clientfd = accept(serverfd,(struct sockaddr*)&client_addr,&client_len);
		if(clientfd == -1)
		{
			fprintf(stderr,"文件名：%s\n函数名：%s\n行号：%d\n错误内容：%s\n",__FILE__,__func__,__LINE__,strerror(errno));
			exit(EXIT_FAILURE);
		}
/*		Lcmsg link_clientfd = {};//定义容纳客户端地址和用户链表头的结构体
		link_clientfd.clientfd = clientfd;
		link_clientfd.userlink = userlink;
		link_clientfd.onlink = onlink;
*/
		char ip_buffer[1024] = "";
		printf("IP:%s\tID:%d\t链接服务器成功！\n",inet_ntop(AF_INET,&client_addr.sin_addr.s_addr,ip_buffer,1024),clientfd);

		//开辟线程对客服端做点对点服务

		pthread_t pthread;
		pthread_attr_t attr;
		pthread_attr_init(&attr);
		pthread_attr_setdetachstate(&attr,PTHREAD_CREATE_DETACHED);

		int err = 0;
		if((err = pthread_create(&pthread,&attr,server_receive,(void*)clientfd)) != 0)
		{
			fprintf(stderr,"文件名：%s\n函数名：%s\n行号：%d\n错误内容：%s\n",__FILE__,__func__,__LINE__,strerror(errno));
			exit(EXIT_FAILURE);
		}
	}
}

void* server_receive(void* arg)//服务器数据接收线程
{
	int clientfd = (int)arg;

	//调用服务器接收线程控制层
	server_ctrl_1(clientfd);


	return NULL;
}
